diff --git a/arch/x86/lib/zimage.c b/arch/x86/lib/zimage.c
index e1387bb..4167906 100644
--- a/arch/x86/lib/zimage.c
+++ b/arch/x86/lib/zimage.c
@@ -365,6 +365,35 @@ int do_zboot(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 	return -1;
 }
 
+int do_loade820(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	struct e820map *memmap = (struct e820map *)0x8000;
+	if (argc >= 2)
+		memmap = (struct e820map *)simple_strtoul(argv[1], NULL, 16);
+
+	memmap->nr_map = install_e820_map(E820_X_MAX, memmap->map);
+	printf("## E820 Loaded to 0x%08lX, number %d\n", (ulong)memmap, memmap->nr_map);
+	if (memmap->nr_map <= 0)
+		return -1;
+	else {
+		printf("e820map:\n");
+		int i;
+		for (i = 0; i < memmap->nr_map; i++) {
+			uint64_t begin = memmap->map[i].addr, end = begin + memmap->map[i].size;
+			printf("  memory: %08llx, [%08llx, %08llx], type = %d.\n",
+					memmap->map[i].size, begin, end - 1,
+					memmap->map[i].type);
+		}
+		return 0;
+	}
+}
+
+U_BOOT_CMD(
+	loade820,      2,      0,      do_loade820,
+	"Load e820map to addr",
+	"[address]\n"
+);
+
 U_BOOT_CMD(
 	zboot, 5, 0,	do_zboot,
 	"Boot bzImage",
diff --git a/common/cmd_elf.c b/common/cmd_elf.c
index ab9c7e3..65dcbce 100644
--- a/common/cmd_elf.c
+++ b/common/cmd_elf.c
@@ -19,6 +19,7 @@
 #include <net.h>
 #include <elf.h>
 #include <vxworks.h>
+#include <asm/bootparam.h>
 
 #if defined(CONFIG_WALNUT) || defined(CONFIG_SYS_VXWORKS_MAC_PTR)
 DECLARE_GLOBAL_DATA_PTR;
@@ -42,6 +43,19 @@ unsigned long do_bootelf_exec(ulong (*entry)(int, char * const[]),
 	if (dcache)
 		dcache_disable();
 
+	struct e820map *memmap = (struct e820map *)0x8000;
+	if (memmap->nr_map <= 0)
+		return -1;
+	else {
+		printf("before exec e820map:\n");
+		int i;
+		for (i = 0; i < memmap->nr_map; i++) {
+			uint64_t begin = memmap->map[i].addr, end = begin + memmap->map[i].size;
+			printf("  memory: %08llx, [%08llx, %08llx], type = %d.\n",
+					memmap->map[i].size, begin, end - 1,
+					memmap->map[i].type);
+		}
+	}
 	/*
 	 * pass address parameter as argv[0] (aka command name),
 	 * and all remaining args
@@ -286,7 +300,7 @@ static unsigned long load_elf_image_phdr(unsigned long addr)
 	for (i = 0; i < ehdr->e_phnum; ++i) {
 		void *dst = (void *)(uintptr_t) phdr->p_paddr;
 		void *src = (void *) addr + phdr->p_offset;
-		debug("Loading phdr %i to 0x%p (%i bytes)\n",
+		printf("Loading phdr %i to 0x%p (%i bytes)\n",
 			i, dst, phdr->p_filesz);
 		if (phdr->p_filesz)
 			memcpy(dst, src, phdr->p_filesz);
diff --git a/common/cmd_fat.c b/common/cmd_fat.c
index a12d8fa..d16edec 100644
--- a/common/cmd_fat.c
+++ b/common/cmd_fat.c
@@ -16,6 +16,7 @@
 #include <part.h>
 #include <fat.h>
 #include <fs.h>
+#include <elf.h>
 
 int do_fat_fsload (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
@@ -38,6 +39,88 @@ U_BOOT_CMD(
 	"      be printed and performance will suffer for the load."
 );
 
+
+int do_bootu(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	unsigned long addr = 0x10000;
+	const char *filename;
+	int len_read;
+
+	if (argc < 2)
+		return CMD_RET_USAGE;
+	if (argc > 4)
+		return CMD_RET_USAGE;
+
+	if (fs_set_blk_dev(argv[1], (argc >= 3) ? argv[2] : NULL, FS_TYPE_FAT))
+		return 1;
+
+	if (argc == 4) {
+		filename = argv[3];
+	} else {
+		filename = getenv("bootfile");
+		if (!filename) {
+			puts("** No boot file defined **\n");
+			return 1;
+		}
+	}
+
+	len_read = fs_read(filename, addr, 0, 4096);
+	if (len_read <= 0)
+		return 1;
+
+	Elf32_Ehdr *ehdr;		/* Elf header structure pointer     */
+	Elf32_Phdr *phdr;		/* Program header structure pointer */
+	int i;
+
+	ehdr = (Elf32_Ehdr *) addr;
+	if (!IS_ELF(*ehdr)) {
+		printf("## No elf image at address 0x%08lx\n", addr);
+		return 1;
+	}
+	phdr = (Elf32_Phdr *) (addr + ehdr->e_phoff);
+
+	/* Load each program header */
+	for (i = 0; i < ehdr->e_phnum; ++i) {
+		void *dst = (void *)(uintptr_t) phdr->p_paddr;
+		printf("Loading phdr %i to 0x%p (%i bytes)\n",
+			i, dst, phdr->p_filesz);
+		if (phdr->p_filesz) {
+			if (fs_set_blk_dev(argv[1], (argc >= 3) ? argv[2] : NULL, FS_TYPE_FAT))
+				return 1;
+			len_read = fs_read(filename, (ulong)dst, phdr->p_offset, phdr->p_filesz);
+			printf("Len read: %d\n", len_read);
+		}
+		if (phdr->p_filesz != phdr->p_memsz)
+			memset(dst + phdr->p_filesz, 0x00,
+				phdr->p_memsz - phdr->p_filesz);
+		flush_cache((unsigned long)dst, phdr->p_filesz);
+		++phdr;
+	}
+
+	addr = ehdr->e_entry;
+	printf("## Starting application at 0x%08lx ...\n", addr);
+
+	/*
+	 * pass address parameter as argv[0] (aka command name),
+	 * and all remaining args
+	 */
+	unsigned long do_bootelf_exec(ulong (*entry)(int, char * const[]),
+			int argc, char * const argv[]);
+	if (do_bootelf_exec((void *)addr, argc - 1, argv + 1) != 0) {
+		printf("## Application terminated");
+		return 1;
+	}
+	return 0;
+}
+
+
+U_BOOT_CMD(
+	bootu,	4,	0,	do_bootu,
+	"load ELF file from a dos filesystem",
+	"<interface> [<dev[:part]>]  <filename>\n"
+	"    - Load ELF file 'filename' from 'dev' on 'interface'"
+);
+
 static int do_fat_ls(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	return do_ls(cmdtp, flag, argc, argv, FS_TYPE_FAT);
